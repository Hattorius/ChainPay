"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[271],{5006:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=t(4848),i=t(8453);const r={sidebar_position:2},s="Examples",o={id:"JS-SDK/example",title:"Examples",description:"In this section, we'll demonstrate the technologies we use for our",source:"@site/docs/JS-SDK/example.md",sourceDirName:"JS-SDK",slug:"/JS-SDK/example",permalink:"/docs/JS-SDK/example",draft:!1,unlisted:!1,editUrl:"https://github.com/Hattorius/ChainPay/tree/main/docs/docs/JS-SDK/example.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"ideaSidebar",previous:{title:"Installation",permalink:"/docs/JS-SDK/install"},next:{title:"API",permalink:"/docs/category/api"}},c={},d=[{value:"Creating a transaction",id:"creating-a-transaction",level:2},{value:"Viem.sh",id:"viemsh",level:3},{value:"Ethers.js",id:"ethersjs",level:3},{value:"Do it yourself",id:"do-it-yourself",level:3},{value:"Displaying a transaction",id:"displaying-a-transaction",level:2},{value:"Our widget (redirect)",id:"our-widget-redirect",level:3},{value:"Our widget (iframe)",id:"our-widget-iframe",level:3},{value:"Do it yourself",id:"do-it-yourself-1",level:3},{value:"Paying a transaction",id:"paying-a-transaction",level:2},{value:"Verifying a transaction payment",id:"verifying-a-transaction-payment",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"examples",children:"Examples"})}),"\n",(0,a.jsxs)(n.p,{children:["In this section, we'll demonstrate the technologies we use for our\n",(0,a.jsx)(n.a,{href:"https://chainpay.dev/",children:"home page"})," and the payment request form."]}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-transaction",children:"Creating a transaction"}),"\n",(0,a.jsxs)(n.p,{children:["Creating a transaction is the first step to receiving tokens through ChainPay.\nYou define the token you want to receive, the amount, and the recipient to whom\nthe tokens should be forwarded. Note that payments can only be processed if the\n",(0,a.jsx)(n.code,{children:"recipient"})," is either the signer or a smart contract registered with ChainPay,\nwhere the signer is also registered as the contract's signer."]}),"\n",(0,a.jsx)(n.h3,{id:"viemsh",children:(0,a.jsx)(n.a,{href:"https://viem.sh/",children:"Viem.sh"})}),"\n",(0,a.jsxs)(n.p,{children:["To create a payment request using Viem, you just need to specify which tokens\nyou want to receive and pass the relevant information to the Viem\n",(0,a.jsx)(n.a,{href:"https://viem.sh/docs/clients/wallet",children:(0,a.jsx)(n.code,{children:"WalletClient"})}),". Typically, creating a\npayment request with Viem is done on the client side by users looking to\ninitiate a transaction."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay, { type TransactionType } from 'chainpay';\n\nconst transaction: TransactionType = await chainpay.createTransaction({\n  walletClient, // user's wallet client\n  account: walletAccount, // user's wallet address\n  token: '0xe9e7cea3dedca5984780bafc599bd69add087d56', // BUSD\n  amount: BigInt('10000000000000000000'), // $10 equivalent\n  data_string: Date.now().toString(), // custom data, like user ID or another identifier\n  type: 'viem',\n});\n\n// Share transaction.encoded, which contains all the data for the transaction as a string\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ethersjs",children:(0,a.jsx)(n.a,{href:"https://ethers.org/",children:"Ethers.js"})}),"\n",(0,a.jsx)(n.p,{children:"Creating a payment request using Ethers.js is typically done on the server side,\nwhen the developer wants to initiate a payment."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay, { type TransactionType } from 'chainpay';\nimport { Wallet } from 'ethers';\n\n// Import your private key\nconst wallet = new Wallet('0x...');\n\nconst transaction: TransactionType = await chainpay.createTransaction({\n  signer: wallet,\n  recipient: undefined, // optional, defaults to `wallet.address` if not specified\n  token: '0xe9e7cea3dedca5984780bafc599bd69add087d56', // BUSD\n  amount: BigInt('10000000000000000000'), // $10 equivalent\n  data_string: Date.now().toString(), // custom data, like user ID or another identifier\n  type: 'ethers',\n});\n\n// Share transaction.encoded, which contains all the data for the transaction as a string\n"})}),"\n",(0,a.jsx)(n.h3,{id:"do-it-yourself",children:"Do it yourself"}),"\n",(0,a.jsx)(n.p,{children:"If you'd prefer to handle things manually, whether you're using a different\nlibrary or simply because you're a coding wizard, here's an example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay from 'chainpay';\n\nconst { data, messageHash } = chainpay.createTransactionRaw({\n  recipient: '0x7982985F05a9dabD3F26dC81CB161f440BE48eE5', // my wallet address (hehe)\n  token: '0xe9e7cea3dedca5984780bafc599bd69add087d56', // BUSD\n  amount: BigInt('10000000000000000000'), // $10 equivalent\n  data_string: '', // either `data_string` or `data_raw` must be set\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once this is done, you can review the ",(0,a.jsx)(n.code,{children:"data"})," (which will be your input converted\nto hex), and the sign ",(0,a.jsx)(n.code,{children:"messageHash"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"displaying-a-transaction",children:"Displaying a transaction"}),"\n",(0,a.jsx)(n.h3,{id:"our-widget-redirect",children:"Our widget (redirect)"}),"\n",(0,a.jsxs)(n.p,{children:["One of the simplest ways to allow your users to make a payment is by redirecting\nthem to our page. The ",(0,a.jsx)(n.code,{children:"TransactionType"})," object, returned when creating a\ntransaction, includes a ",(0,a.jsx)(n.code,{children:"pay"})," key. This ",(0,a.jsx)(n.code,{children:"pay"})," key contains a URL where the user\ncan be redirected to complete the payment."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay, { type TransactionType } from 'chainpay';\n\n// Retrieve the transaction object, for example:\nconst transaction: TransactionType =\n  chainpay.utils.decodeTransaction(encodedTransaction);\n\nwindow.open(transaction.pay, '_blank');\n"})}),"\n",(0,a.jsx)(n.h3,{id:"our-widget-iframe",children:"Our widget (iframe)"}),"\n",(0,a.jsx)(n.p,{children:"Alternatively, you can display our payment widget directly within your webpage\nusing an iframe. The ChainPay library provides built-in support for this, and\nit\u2019s very easy to implement."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<iframe id="pay_me"></iframe>\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay, { type TransactionType } from 'chainpay';\n\n// Retrieve the transaction object, for example:\nlet transaction: TransactionType =\n  chainpay.utils.decodeTransaction(encodedTransaction);\n\nawait transaction.widget('#pay_me');\n// \"Paid\" message received from iframe!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the widget is embedded into the iframe you created. The widget\nwill notify your webpage once the payment is completed. That's why the code uses\n",(0,a.jsx)(n.code,{children:"await"}),"\u2014it waits until the payment is processed before continuing with any\nsubsequent logic."]}),"\n",(0,a.jsx)(n.h3,{id:"do-it-yourself-1",children:"Do it yourself"}),"\n",(0,a.jsx)(n.p,{children:"So, you're feeling adventurous and want to take control of things yourself\nagain, huh? Well, we can't hold your hand through this part, but there's one\nthing you really need to watch out for:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay from 'chainpay';\n\nlet transaction: TransactionType;\nlet userSelectedToken = '0x...'; // The token your user wants to use for payment\n\nconst pool = const chainpay.utils.findPool(transaction.token, userSelectedToken);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It's crucial to ensure that the token your user has selected is supported by\nChainPay. ",(0,a.jsx)(n.a,{href:"./../future",children:"Currently, ChainPay is still in its early stages"}),", and\nnot all token pools are supported. Running the ",(0,a.jsx)(n.code,{children:"findPool"})," function provides\nimportant information. If the result is ",(0,a.jsx)(n.code,{children:"undefined"}),", the token combination is\nnot supported by ChainPay at this time. Otherwise, it returns an object\ncontaining the ",(0,a.jsx)(n.code,{children:"feeTier"}),", which will be essential for the next steps."]}),"\n",(0,a.jsx)(n.h2,{id:"paying-a-transaction",children:"Paying a transaction"}),"\n",(0,a.jsxs)(n.p,{children:['Currently, this process is only available in "do it yourself" format. If you\nprefer a more straightforward approach, consider using the widgets described\nabove. The ',(0,a.jsx)(n.code,{children:"pay"})," function provides all the necessary data to send a transaction.\nBelow is an example of how to use it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay, { type TransactionType } from 'chainpay';\n\n// Retrieve the transaction object, for example:\nlet transaction: TransactionType =\n  chainpay.utils.decodeTransaction(encodedTransaction);\n\nconst data: PaymentData<typeof chainpay.abi> = await chainpay.pay({\n  transaction, //  You can directly input the TransactionType object or the encoded transaction\n  token: '0x...', // The token you or your user wants to use for payment\n  amount: BigInt('98457367349'), // The amount to be paid\n  feeTier: undefined, // Optional: if not set, the library will automatically run `utils.findPool`\n  chainpayContract: chainpay.constants.CHAINPAY_CONTRACT_ADDRESS,\n  type: 'raw', // Currently, only 'raw' type is supported\n});\n\nif (data.approve) {\n  // Approve token spending for the `CHAINPAY_CONTRACT_ADDRESS` with the specified token and amount\n}\n\n// Example with viem.sh:\nconst payResult = await publicClient.simulateContract({\n  address: data.chainpayContract,\n  abi: data.abi,\n  functionName: data.functionName,\n  account: walletAccount, // Retrieve this from viem\n  args: data.args,\n  value: data.value as any,\n  chain: bsc, // Import this from 'viem/chains'\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"data"})," variable will now contain all the data you need to pay the\ntransaction yourself. Please check the API docs for further information on what\nit returns and how to use it."]}),"\n",(0,a.jsxs)(n.p,{children:["You may have noticed that you need to specify the ",(0,a.jsx)(n.code,{children:"amount"})," even if the user is\npaying with a different token. This means you will need to calculate how much of\ntokenB the user needs to send in order for you to receive the correct amount of\ntokenA. Be sure to include some slippage to prevent the transaction from failing\nunexpectedly. Don\u2019t worry\u2014any excess tokens sent by the user will be\nautomatically refunded by the ChainPay contract."]}),"\n",(0,a.jsx)(n.h2,{id:"verifying-a-transaction-payment",children:"Verifying a transaction payment"}),"\n",(0,a.jsxs)(n.p,{children:["It is always recommended to verify whether the transaction has been fully paid,\neven if the ",(0,a.jsx)(n.a,{href:"#our-widget-iframe",children:"iframe widget"})," indicates that payment was\nsuccessful. Since this confirmation happens on the client side, it could be\ntampered with. To ensure security, verify the payment on your server using the\noriginal signature."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import chainpay from 'chainpay';\n\nconst paid: boolean = chainpay.isPaid(\n  chainpay.constants.CHAINPAY_CONTRACT_ADDRESS,\n  signature\n);\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The signature can either be saved on your end when the transaction is created\nor extracted from the ",(0,a.jsx)(n.code,{children:"transaction.signature"})," field."]}),"\n",(0,a.jsx)(n.li,{children:"If you extract the signature from the transaction, ensure that the signature\nis indeed yours and that the transaction data is accurate before proceeding\nwith the verification."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);